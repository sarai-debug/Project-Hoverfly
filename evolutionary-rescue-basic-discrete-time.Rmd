---
title: "Project Life Stage"
author: "Claudia Bank & Charith & Sarai"
date: "2025-10-14"
output:
  html_document:
    df_print: paged
---

# Question:

*How do new mutations that affect the different life stages influence evolutionary rescue of the population under temperature stress?*

# List of variables

-   `t` generation index, one generation per step
-   `A_w(t)` number of wild-type adult individuals at generation t
-   `A_m(t)` number of mutated adult individuals at generation t
-   `E_w(t)` number of wild-type eggs at generation t
-   `E_m(t)` number of mutated eggs at generation t
-   `N(t)` total population size at generation t
-   `p_t` frequency of mutant among adults

# List of parameters

-   `A_0` initial total adult population size
-   `A_w_0` initial number of wild-type adults
-   `A_m_0` initial number of mutant adults
-   `f_w` fecundity wild-type adults, eggs laid per adult per generation (r_A already included in this parameter)
-   `f_m` fecundity mutated adults, eggs laid per adult per generation (s_A already included in this parameter)
-   `pZ_w` probability of survival of wild-type eggs into next generation (baseline survival rate of eggs + reduction of survival due to heat r_E)
-   `pZ_m` probability of survival of mutant eggs into next generation (baseline survival rate of eggs + advantage of survival s_E)
-   (`s_A` fecundity advantage for mutant adults)
-   (`s_E` egg survival advantage for mutant eggs)
-   (`s_E_0` baseline survival rate of eggs -\> adult, in stress-free environment)
-   (`r_A` reduction in wild_type adult fecundity due to heat)
-   (`r_E` reduction in wild_type eggs survival due to heat)
-   `mu_rate` mutation rate, probability of mutant eggs laid by wild-type adults

# Base Code

```{r}
# Simulating one generation:
simulate_one_gen_ls <- function(Z_w, Z_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate) {

   # we assume that the number of individuals (eggs) is recorded in spring, before eggs hatch and adults reproduce 
  
   # after winter, adults hatch from eggs with hatching rate between 0 and 1

   newAdults_w <- rbinom(1, Z_w,  hZ_w)

   newAdults_m <- rbinom(1, Z_m,  hZ_m)

   # adults produce eggs with fecundity rate f (number of offspring produced per adult)

   newEggs_w <- rpois(1, newAdults_w * f_w)

   newEggs_m <- rpois(1, newAdults_m * f_m)

   # draw new mutants according to Poisson distribution

   mut_w_to_m <- rpois(1, newEggs_w * mut_rate)
   
   # ensure do not mutate more eggs than exist
   
   if (mut_w_to_m > newEggs_w) mut_w_to_m <- newEggs_w
   
   # calculating next generation with no negative number
   
   Z_w_test <- max(Z_w - newAdults_w + newEggs_w - mut_w_to_m, 0)
   Z_m_test <- max(Z_m - newAdults_m + newEggs_m + mut_w_to_m, 0)
   
   # determine new population sizes of eggs, taking into account mortality during winter

   Z_w_new <- rbinom(1, Z_w_test, pZ_w)
   Z_m_new <- rbinom(1, Z_m_test, pZ_m)
   
   return(c(Z_w_new, Z_m_new))
 }

 # Print the function

 print(simulate_one_gen_ls(Z_w=1000, Z_m=0, f_w=2, f_m=2.5, hZ_w=0.5, hZ_m=0.5, pZ_w=0.1, pZ_m=0.1, mut_rate=0.1))

```

# Simulating a population during a period of time

```{r}

simulate_pop <- function(Z_init_w, Z_init_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(Z_init_w, Z_init_m)
  # initiate the variables
  pop_new <- c(Z_init_w, Z_init_m)
  
  # run the simulation until generation t_max
  for (i in 1:(t_max+1)) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen_ls(Z_w = pop_new[1], Z_m = pop_new[2], f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (is.na(pop_new[1]) | is.na(pop_new[2])) break
    if (pop_new[1]+pop_new[2]>=100*(Z_init_w+ Z_init_m) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
 # rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("w","m")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used throughout
max_gen <- 200
# create your simulation data
output <- simulate_pop(Z_init_w = 100, Z_init_m = 0, f_w = 3, f_m = 3, hZ_w = 0.4, hZ_m = 0.5, pZ_w = 0.4, pZ_m = 0.5, mut_rate = 0.001,t_max = max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Number of Eggs")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
legend("top", legend = c("Wildtype eggs", "Mutant eggs"), 
       col = c("blue", "red"), lty = 1)


```

# Running and recording many rounds

```{r}
num_rounds <- 100
extinct_count <- 0
rescue_count <- 0


for (i in 1:num_rounds) {
  
  Z_init_w <- 100
  Z_init_m <- 50
  
  round_gen <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                            hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, 
                            mut_rate = 0.02,t_max = max_gen)
  
  total_pop <- round_gen[dim(round_gen)[1],1] + round_gen[dim(round_gen)[1],2]

  
   if (total_pop == 0) {
     extinct_count <- extinct_count + 1
   }

   else if (total_pop > (Z_init_w + Z_init_m)){
     rescue_count <- rescue_count + 1
   }

  prob_rescue <- rescue_count/num_rounds*100
  prob_extinct <- extinct_count/num_rounds*100
  
}
prob_rescue
```

# Rescue probability with varying mutation rates

```{r}
num_rounds <- 400
inita_pop <- 1000+50
mut_rates <- seq(0, 0.02, by = 0.005)

    
    # creating a data frame to keep all output
    
    results <- data.frame(mut_rate=numeric(), rescue_prob=numeric(), extinct_prob=numeric(), rescue_by_w=numeric(), rescue_by_m=numeric())
    freq_df <- data.frame(array(NA, dim =c(0,3), dimnames = list(c(), c("mutation_rate", "wildtype", "mutant"))))
 
    # for (i in 1:num_rounds)   
  for (mut in mut_rates) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds){
   
  
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                            hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, 
                            mut_rate = mut_rates,t_max = max_gen)
  
    # total_pop <- round_gen[dim(round_gen)[1],1] + round_gen[dim(round_gen)[1],2]
    total_pop <- sum(tail(sim, 1))
  
  
    if (total_pop == 0){ 
        extinct_count <- extinct_count + 1
    
    # if (total_pop > inita_pop)
    }
    else{
      rescue_count <- rescue_count + 1
      freq_df <- rbind(freq_df, c(mut, sim[nrow(sim),1]/total_pop, sim[nrow(sim),2]/total_pop))
   }
}
    
   # result for each mutation rate
  results <- rbind(results, data.frame(mut_rates = mut, 
                                       prob_rescue = rescue_count/num_rounds * 100, 
                                       prob_extinct = extinct_count/num_rounds * 100))
}
    print(results)
    
    colnames(freq_df) <- c("mutation_rate", "wildtype", "mutant")
    print(freq_df)
    
    # plot for rescue probability
    
    plot(results$mut_rates, results$prob_rescue, type='b',  
         col='darkgreen', pch=21, xlab='Mutation rate', 
         ylab='Rescue probability (%)',
         main='Evolutionary Rescue vs Mutation Rate')
    
    # frequency plot against mutation rate
    
    plot(freq_df$mutation_rate, freq_df$mutant, type='p',  
         col='darkgreen', pch=21, xlab='Mutation rate', 
         ylab='Frequency of Mutant at End of Simulation',
         main='Frequency at Rescue vs Mutation Rate')
    
    # boxplot for frequency and mutation rate
    boxplot(mutant ~ mutation_rate,
        data = freq_df,
        col = "darkgreen",
        border = "black",
        xlab = "Mutation rate",
        ylab = "Frequency of Mutant at End of Simulation",
        main = "Frequency at Rescue vs Mutation Rate")
    
```

--\> maybe other parameters bc of different life stages

## A small analysis

As you can see if you simulate and plot the output several times, there is a lot of stochasticity/variation in the outcome. Therefore, to get interpretable results, we have to run the simulation many times and summarize the outcome depending on the question of our study. Here I am showing an example in which we record the time and the value of the lowest population size (or the time of extinction, if the population size eventually goes to 0). Usually, we want to study this for a range of model parameters; here I am varying the decay rate and the selection coefficient. Other (maybe more interesting) features to study would be the following:

-   rescue probability dependent on initial frequency and selection coefficient
-   time at which the rescue mutation occurs first if it rescues, vs. if it doesn't rescue, dependent on initial population size and mutation rate
-   time until the population has recovered in case it becomes rescued, dependent on mutation rate and selection coefficient
-   ...

```{r}
# set some parameters to fixed values
init_a <- 100
init_A <- 0
m_rate <- 0.001
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 100

# set parameters to vary
s_values <- c(0.2,0.3,0.4)
r_values <- c(0.05,0.1,0.15)

# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
  # loop over selection coefficients
  for(sval in s_values){
    # different way of running many simulations: make replicates using "repeat" function with a counter i
    # reset counter
    i<-1
    repeat {
      # increase counter by one
      i<-i+1
      # run the simulation once
      one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
      # determine total population sizes
      total_size <- one_run[,1]+one_run[,2]
      # determine minimum population size
      min_size <- min(total_size)
      # determine (first) generation at which this population size occurred
      min_gen <- as.numeric(which(total_size==min_size)[1])
      # enter the data into the table
      data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
      # stop the repeated computation after no_replicates times
      if(i>no_replicates) break
    }
  }
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
```

## Next steps

So, where do you go from here? Of course you won't just stare at these tables (at least not forever). Visualization would be a good step to see how the minimum population size varies with the decay rate and the selection coefficient. And you might want to include only the cases in which rescue happens, and also extract the rescue probability in parallel. However, the idea is that you pick a question that you find (more) interesting and implement modified versions of this code to address your question of choice.
