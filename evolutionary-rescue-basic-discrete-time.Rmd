---
title: "Project Life Stage"
author: "Claudia Bank & Charith & Sarai"
date: "2025-10-14"
output:
  html_document:
    df_print: paged
---

## Question:

*How do new mutations that affect the different life stages influence evolutionary rescue of the population under temperature stress?*

## Simulating evolutionary rescue in discrete time

In this notebook, we are implementing simulations of evolutionary rescue by a single mutation in discrete time, as discussed and analyzed in the work by Orr & Unckless. The model is as follows: a haploid population starts with a given number of wild-type and mutant individuals. Because of a sudden environmental change, the wild type is unfit and declines in the new environment. The mutant is beneficial and can survive and expand in the new environment, but it starts at a low (or zero) frequency in the total population. In order to rescue the population, it has to outcompete the wild type. If the mutant is not present at time 0, it has to appear through mutation and then spread in the population before extinction occurs.

## List of variables

-   `t` generation index, one generation per step
-   `A_w(t)` number of wild-type adult individuals at generation t
-   `A_m(t)` number of mutated adult individuals at generation t
-   `E_w(t)` number of wild-type eggs at generation t
-   `E_m(t)` number of mutated eggs at generation t
-   `N(t)` total population size at generation t
-   `p_t` frequency of mutant among adults

## List of parameters

-   `A_0` initial total adult population size
-   `A_w_0` initial number of wild-type adults
-   `A_m_0` initial number of mutant adults
-   `f_w` fecundity wild-type adults, eggs laid per adult per generation (r_A already included in this parameter)
-   `f_m` fecundity mutated adults, eggs laid per adult per generation (s_A already included in this parameter)
-   `pZ_w` probability of survival of wild-type eggs into next generation (baseline survival rate of eggs + reduction of survival due to heat r_E)
-   `pZ_m` probability of survival of mutant eggs into next generation (baseline survival rate of eggs + advantage of survival s_E)
-   (`s_A` fecundity advantage for mutant adults)
-   (`s_E` egg survival advantage for mutant eggs)
-   (`s_E_0` baseline survival rate of eggs -\> adult, in stress-free environment)
-   (`r_A` reduction in wild_type adult fecundity due to heat)
-   (`r_E` reduction in wild_type eggs survival due to heat)
-   `mu_rate` mutation rate, probability of mutant eggs laid by wild-type adults

## List of parameters and variables of base code

-   $N_a$ current size of the wild-type (a) population (changes over time)
-   $N_A$ current size of the mutant (A) population (changes over time)
-   `N_init_a` initial population size of wild-type population (should be a positive integer)
-   `N_init_A` initial population size of the mutant population (should be a non-negative integer)
-   `decay_rate` detrimental effect of the environment on the wild type (i.e., the wild-type population decays at this rate; should be \>0 to induce potential extinction)
-   `sel_coeff` selective advantage of the mutant over the wild type (should be \>decay_rate to allow for evolutionary rescue)
-   `mut_rate` mutation rate from the wild type to the mutant genotype (should be \>0 and small)
-   `t_max` number of generations after which to stop the simulation (should be an integer \>0; this is not a model parameter but a setting for the simulations). In the code presented here, the simulation stops automatically if the population goes extinct, or if it recovers and exceeds 1.5 times the original total population size, so `t_max` can be set to a large value without creating extremely long simulation times.

## Simulate one generation of population size change

We want to observe the numbers of wild-type and mutant individuals over time. As first step, we simulate one generation of the population. At time $t$, the population has $N_a$ wild-type individuals and $N_A$ mutant individuals. First, these reproduce. This is modeled by drawing a Poisson random variable according to the expected absolute number $N_a \cdot (1-r)$ of wild-type individuals, where $r$ is the decay rate of the wild type, and $N_A \cdot (1-r+s)$ of mutant individuals, where $s$ is the selective advantage of the mutant over the wild time. Then mutation from $a$ to $A$ occurs as a Poisson random variable according to the given mutation rate. This defines the composition of the population at time $t+1$.

```{r}
simulate_one_gen <- function(N_a, N_A, decay_rate, sel_coeff, mut_rate) {
  # draw offspring according to Poisson distribution
  offsp_a <- rpois(1, N_a * (1-decay_rate))
  offsp_A <- rpois(1, N_A * (1-decay_rate+sel_coeff))
  # draw new mutants according to Poisson distribution
  mut_a_to_A <- rpois(1, offsp_a * mut_rate)
  
  # determine new population sizes of wild type and mutant
  N_a_new <- max(offsp_a - mut_a_to_A, 0)
  N_A_new <-  offsp_A + mut_a_to_A
  
  return(c(N_a_new, N_A_new))
}
# Test the function
print(simulate_one_gen(100,0,0.1,0.2,0.01))
```

## This is the code for our project:

```{r}
A_w <- A_w_0
A_m <- A_m_0
one_generation <- function(A_w, A_m, f_w, f_m, s_A, s_E, s_E_0, r_A, r_E, mu_rate){
  # draw offspring according to Poisson distribution
  E_w <- rpois(1, A_w * (f_w - r_A))
  E_m <- rpois(1, A_m * (f_m + s_A))
  
  # draw new mutants according to Poisson distribution
  new_mutants <- rpois(1, E_w * mu_rate)
  
  # determine new population sizes of wild type and mutant
  
  # new adults
  A_w_new <- max((E_w - new_mutants)*(s_E_0 - r_E), 0)
  A_m_new <- (E_m + new_mutants)*(s_E_0 + s_E)
  
  # new eggs
  E_w <- ((E_w - new_mutants) - A_w_new)*somethingidk
  E_m <- ((E_m + new_mutants) - A_m_new)*somethingidk
  
  

  return(c(A_, N_A_new))
}
```


## New code 
```{r}
simulate_one_gen_ls <- function(Z_w, Z_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate) {

   # we assume that the number of individuals (eggs) is recorded in spring, before eggs hatch and adults reproduce 
  
   # after winter, adults hatch from eggs with hatching rate between 0 and 1

   newAdults_w <- rbinom(1, Z_w,  hZ_w)

   newAdults_m <- rbinom(1, Z_m,  hZ_m)

   # adults produce eggs with reproduction rate r

   newEggs_w <- rpois(1, newAdults_w * f_w)

   newEggs_m <- rpois(1, newAdults_m * f_m)

   # draw new mutants according to Poisson distribution

   mut_w_to_m <- rpois(1, newEggs_w * mut_rate)
   
   # ensure do not mutate more eggs than exist
   
   if (mut_w_to_m > newEggs_w) mut_w_to_m <- newEggs_w
   
   # calculating next generation with no negative number
   
   Z_w_test <- max(Z_w - newAdults_w + newEggs_w - mut_w_to_m, 0)
   Z_m_test <- max(Z_m - newAdults_m + newEggs_m + mut_w_to_m, 0)
   
   # determine new population sizes of eggs, taking into account mortality during winter

  Z_w_new <- rbinom(1, Z_w_test, pZ_w)
   Z_m_new <- rbinom(1, Z_m_test, pZ_m)
   
   return(c(Z_w_new, Z_m_new))
 }

 # Test the function

 print(simulate_one_gen_ls(Z_w=1000, Z_m=0, f_w=2, f_m=2.5, hZ_w=0.5, hZ_m=0.5, pZ_w=0.1, pZ_m=0.1, mut_rate=0.1))

```

## New code 2

```{r}

simulate_pop <- function(Z_init_w, Z_init_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(Z_init_w, Z_init_m)
  # initiate the variables
  pop_new <- c(Z_init_w, Z_init_m)
  
  # run the simulation until generation t_max
  for (i in 1:(t_max+1)) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen_ls(Z_w = pop_new[1], Z_m = pop_new[2], f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (is.na(pop_new[1]) | is.na(pop_new[2])) break
    if (pop_new[1]+pop_new[2]>=100*(Z_init_w+ Z_init_m) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
 # rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("w","m")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used throughout
max_gen <- 200
# create your simulation data
output <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, mut_rate = 0,t_max = max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Number of Eggs")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
legend("top", legend = c("Wildtype eggs", "Mutant eggs"), 
       col = c("blue", "red"), lty = 1)


```



## Running and recording many rounds
```{r}
num_rounds <- 100
extinct_count <- 0
rescue_count <- 0


for (i in 1:num_rounds) {
  
  Z_init_w <- 100
  Z_init_m <- 50
  
  round_gen <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                            hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, 
                            mut_rate = 0.02,t_max = max_gen)
  
  total_pop <- round_gen[dim(round_gen)[1],1] + round_gen[dim(round_gen)[1],2]

  
   if (total_pop == 0) {
     extinct_count <- extinct_count + 1
   }

   else if (total_pop > (Z_init_w + Z_init_m)){
     rescue_count <- rescue_count + 1
   }

  prob_rescue <- rescue_count/num_rounds*100
  prob_extinct <- extinct_count/num_rounds*100
  
}
prob_rescue
```



```{r}
num_rounds <- 100
inita_pop <- 100+50
mut_rates <- seq(0, 0.02, by = 0.005)

    
    # creating a data frame to keep all output
    
    results <- data.frame(mut_rate=numeric(), rescue_prob=numeric(), extinct_prob=numeric())
 
    # for (i in 1:num_rounds)   
  for (mut in mut_rates) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds){
   
  
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 5, f_w = 5, f_m = 5, 
                            hZ_w = 0.3, hZ_m = 0.4, pZ_w = 0.1, pZ_m = 0.6, 
                            mut_rate = mut,t_max = max_gen)
  
    # total_pop <- round_gen[dim(round_gen)[1],1] + round_gen[dim(round_gen)[1],2]
    total_pop <- sum(tail(sim, 1))
  
  
    if (total_pop == 0) 
      extinct_count <- extinct_count + 1
    
    # if (total_pop > inita_pop)
    else
      rescue_count <- rescue_count + 1
    
}
    
   # result for each mutation rate
  results <- rbind(results, data.frame(mut_rates = mut,   prob_rescue = rescue_count/num_rounds * 100,
  prob_extinct = extinct_count/num_rounds * 100))
  

}
    print(results)
    
    # plot for rescue probability
    
    plot(results$mut_rates, results$prob_rescue, type='b', col='darkgreen', pch=21,
     xlab='Mutation rate', ylab='Rescue probability (%)',
     main='Evolutionary Rescue vs Mutation Rate')
    
    
```


--> mut_rate breaks pois distr for some reason giving NA values 

--> lower more realistic mutation rates!!!!

--> maybe other parameters bc of different life stages 




## A small analysis

As you can see if you simulate and plot the output several times, there is a lot of stochasticity/variation in the outcome. Therefore, to get interpretable results, we have to run the simulation many times and summarize the outcome depending on the question of our study. Here I am showing an example in which we record the time and the value of the lowest population size (or the time of extinction, if the population size eventually goes to 0). Usually, we want to study this for a range of model parameters; here I am varying the decay rate and the selection coefficient. Other (maybe more interesting) features to study would be the following:

-   rescue probability dependent on initial frequency and selection coefficient
-   time at which the rescue mutation occurs first if it rescues, vs. if it doesn't rescue, dependent on initial population size and mutation rate
-   time until the population has recovered in case it becomes rescued, dependent on mutation rate and selection coefficient
-   ...

```{r}
# set some parameters to fixed values
init_a <- 100
init_A <- 0
m_rate <- 0.001
max_gen <- 1000
# determine how often to run the simulation for each set of parameters
no_replicates <- 100

# set parameters to vary
s_values <- c(0.2,0.3,0.4)
r_values <- c(0.05,0.1,0.15)

# initialize data table - where to collect the results
data_table <- c()
# run the simulation across all chosen parameters
# loop over decay rates
for(rval in r_values){
  # loop over selection coefficients
  for(sval in s_values){
    # different way of running many simulations: make replicates using "repeat" function with a counter i
    # reset counter
    i<-1
    repeat {
      # increase counter by one
      i<-i+1
      # run the simulation once
      one_run <- simulate_pop(init_a,init_A,rval,sval,m_rate,max_gen)
      # determine total population sizes
      total_size <- one_run[,1]+one_run[,2]
      # determine minimum population size
      min_size <- min(total_size)
      # determine (first) generation at which this population size occurred
      min_gen <- as.numeric(which(total_size==min_size)[1])
      # enter the data into the table
      data_table <- rbind(data_table,c(rval,sval,min_gen,min_size)) # note that we add the varying parameters (decay rate and selection coefficient) to the table too
      # stop the repeated computation after no_replicates times
      if(i>no_replicates) break
    }
  }
}
# define column names of data table
colnames(data_table) <- c("r","s","min_gen","no_min")
# show the first lines of the output
print(head(data_table))
```


## Next steps

So, where do you go from here? Of course you won't just stare at these tables (at least not forever). Visualization would be a good step to see how the minimum population size varies with the decay rate and the selection coefficient. And you might want to include only the cases in which rescue happens, and also extract the rescue probability in parallel. However, the idea is that you pick a question that you find (more) interesting and implement modified versions of this code to address your question of choice.
