---
title: "Project Life Stage"
author: "Claudia Bank & Charith & Sarai"
date: "2025-10-14"
output:
  html_document:
    df_print: paged
---

# Question:

*How do new mutations that affect the different life stages influence evolutionary rescue of the population under temperature stress?*

# List of variables

-   `t` generation index, one generation per step
-   `A_w(t)` number of wild-type adult individuals at generation t
-   `A_m(t)` number of mutated adult individuals at generation t
-   `E_w(t)` number of wild-type eggs at generation t
-   `E_m(t)` number of mutated eggs at generation t
-   `N(t)` total population size at generation t
-   `p_t` frequency of mutant among adults

# List of parameters

-   `A_0` initial total adult population size
-   `A_w_0` initial number of wild-type adults
-   `A_m_0` initial number of mutant adults
-   `f_w` fecundity wild-type adults, eggs laid per adult per generation (r_A already included in this parameter)
-   `f_m` fecundity mutated adults, eggs laid per adult per generation (s_A already included in this parameter)
-   `pZ_w` probability of survival of wild-type eggs into next generation (baseline survival rate of eggs + reduction of survival due to heat r_E)
-   `pZ_m` probability of survival of mutant eggs into next generation (baseline survival rate of eggs + advantage of survival s_E)
-   (`s_A` fecundity advantage for mutant adults)
-   (`s_E` egg survival advantage for mutant eggs)
-   (`s_E_0` baseline survival rate of eggs -\> adult, in stress-free environment)
-   (`r_A` reduction in wild_type adult fecundity due to heat)
-   (`r_E` reduction in wild_type eggs survival due to heat)
-   `mu_rate` mutation rate, probability of mutant eggs laid by wild-type adults

# Base Code

```{r}
# Simulating one generation:
simulate_one_gen_ls <- function(Z_w, Z_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate) {

   # we assume that the number of individuals (eggs) is recorded in spring, before eggs hatch and adults reproduce 
  
   # after winter, adults hatch from eggs with hatching rate between 0 and 1

   newAdults_w <- rbinom(1, Z_w,  hZ_w)

   newAdults_m <- rbinom(1, Z_m,  hZ_m)

   # adults produce eggs with fecundity rate f (number of offspring produced per adult)

   newEggs_w <- rpois(1, newAdults_w * f_w)

   newEggs_m <- rpois(1, newAdults_m * f_m)

   # draw new mutants according to Poisson distribution

   mut_w_to_m <- rpois(1, newEggs_w * mut_rate)
   
   # ensure do not mutate more eggs than exist
   
   if (mut_w_to_m > newEggs_w) mut_w_to_m <- newEggs_w
   
   # calculating next generation with no negative number
   
   Z_w_test <- max(Z_w - newAdults_w + newEggs_w - mut_w_to_m, 0)
   Z_m_test <- max(Z_m - newAdults_m + newEggs_m + mut_w_to_m, 0)
   
   # determine new population sizes of eggs, taking into account mortality during winter

   Z_w_new <- rbinom(1, Z_w_test, pZ_w)
   Z_m_new <- rbinom(1, Z_m_test, pZ_m)
   
   return(c(Z_w_new, Z_m_new))
 }

 # Printing the function with desired parameters
print(simulate_one_gen_ls(Z_w=1000, Z_m=0, f_w=2, f_m=2.5, hZ_w=0.5, hZ_m=0.5, pZ_w=0.1, pZ_m=0.1, mut_rate=0.1))

```

# Simulating a population during a period of time

```{r}

# Creating function to simulate a population during a time period
simulate_pop <- function(Z_init_w, Z_init_m, f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate, t_max) {
  # Create the vector in which to save the results
  pop_vector <- c(Z_init_w, Z_init_m)
  # initiate the variables
  pop_new <- c(Z_init_w, Z_init_m)
  
  # run the simulation until generation t_max
  for (i in 1:(t_max+1)) {
    # redefine the current population one generation later
    pop_new <- simulate_one_gen_ls(Z_w = pop_new[1], Z_m = pop_new[2], f_w, f_m, hZ_w, hZ_m, pZ_w, pZ_m, mut_rate)
    # add the new population sizes to the output vector
    pop_vector <- rbind(pop_vector,pop_new)
    # condition to stop the simulation before t_max: either the population exceeds 1.5 times the original population size, or it goes extinct
    if (is.na(pop_new[1]) | is.na(pop_new[2])) break
    if (pop_new[1]+pop_new[2]>=100*(Z_init_w+ Z_init_m) | pop_new[1]+pop_new[2]==0) break
  }
  
  # define the row and column names of the output vector
 # rownames(pop_vector) <- (0:t_max)[1:length(pop_vector[,1])] # note that the vector has to be cut if the simulation stopped early
  colnames(pop_vector) <- c("w","m")
  # return the result
  return(pop_vector)	
}


# Test the function and plot the result
# set t_max to a value to be used throughout
max_gen <- 200
# create your simulation data
output <- simulate_pop(Z_init_w = 100, Z_init_m = 0, f_w = 3, f_m = 3, hZ_w = 0.4, hZ_m = 0.5, pZ_w = 0.4, pZ_m = 0.5, mut_rate = 0.001,t_max = max_gen)
# show the last few lines of the data table
print(tail(output))
# plot the output - note that the plot range and the x axis have to be adjusted based on the length of the table
# determine x axis range 
x_range <- 0:(length(output[,1])-1)
# this plots the total population size
plot(x_range,output[,1]+output[,2],type='l',ylim=c(0,max(output[,1]+output[,2])),xlab = "Generation",ylab = "Number of Eggs")
# add number of wild type individuals
lines(x_range,output[,1], col="blue")
# add number of mutant individuals
lines(x_range,output[,2], col="red")
legend("top", legend = c("Wildtype eggs", "Mutant eggs"), 
       col = c("blue", "red"), lty = 1)


```

# Running and recording many rounds

```{r}

num_rounds <- 100
extinct_count <- 0
rescue_count <- 0


for (i in 1:num_rounds) {
  
  Z_init_w <- 100
  Z_init_m <- 50
  
  round_gen <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                            hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, 
                            mut_rate = 0.02,t_max = max_gen)
  
  total_pop <- round_gen[dim(round_gen)[1],1] + round_gen[dim(round_gen)[1],2]

  
   if (total_pop == 0) {
     extinct_count <- extinct_count + 1
   }

   else if (total_pop > (Z_init_w + Z_init_m)){
     rescue_count <- rescue_count + 1
   }

  prob_rescue <- rescue_count/num_rounds*100
  prob_extinct <- extinct_count/num_rounds*100
  
}
prob_rescue
```

# Results 

## Rescue probability with varying mutation rates

```{r}

num_rounds <- 400
mut_rates <- seq(0, 0.02, by = 0.005)

    
    # creating a data frame to keep all output
    
    results <- data.frame(mut_rate=numeric(), rescue_prob=numeric(), extinct_prob=numeric(), rescue_by_w=numeric(), rescue_by_m=numeric())
    freq_df <- data.frame(array(NA, dim =c(0,3), dimnames = list(c(), c("mutation_rate", "wildtype", "mutant"))))
 
    # for (i in 1:num_rounds)   
  for (mut in mut_rates) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds){
   
  
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3,
                            hZ_w = 0.5, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5,
                            mut_rate = mut_rates,t_max = max_gen)
    
    total_pop <- sum(tail(sim, 1))
  
  
    if (total_pop == 0){ 
        extinct_count <- extinct_count + 1
    }
    else{
      rescue_count <- rescue_count + 1
      freq_df <- rbind(freq_df, c(mut, sim[nrow(sim),1]/total_pop, sim[nrow(sim),2]/total_pop))
   }
}
    
   # result for each mutation rate
  results <- rbind(results, data.frame(mut_rates = mut, 
                                       prob_rescue = rescue_count/num_rounds * 100, 
                                       prob_extinct = extinct_count/num_rounds * 100))
}
    print(results)
    
    colnames(freq_df) <- c("mutation_rate", "wildtype", "mutant")
    print(freq_df)
    
    # plot for rescue probability
    
    plot(results$mut_rates, results$prob_rescue, type='b',  
         col='darkgreen', pch=21, xlab='Mutation rate', 
         ylab='Rescue probability (%)',
         main='Evolutionary Rescue vs Mutation Rate')
    
```

--\> maybe other parameters bc of different life stages

## Rescue probability with varying wildtype fecundity 

```{r}

num_rounds <- 400
max_gen <- 200

# Range of wildtype fecundity to explore
f_w_values <- seq(1, 6, by = 0.5)   # can adjust based on realistic values

# Create result containers
results <- data.frame(f_w = numeric(), prob_rescue = numeric(), prob_extinct = numeric())
freq_df <- data.frame(array(NA, dim = c(0, 3), dimnames = list(c(), c("f_w", "wildtype", "mutant"))))

# Sweep over wildtype fecundity values
for (f_w in f_w_values) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds) {
    
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, 
                        f_w = f_w, f_m = 2,        # << varying wildtype fecundity
                        hZ_w = 0.5, hZ_m = 0.5, 
                        pZ_w = 0.5, pZ_m = 0.5, 
                        mut_rate = 0.001, t_max = max_gen)
    
    total_pop <- sum(tail(sim, 1))
    
    if (total_pop == 0) { 
      extinct_count <- extinct_count + 1
    } else {
      rescue_count <- rescue_count + 1
      freq_df <- rbind(freq_df, c(f_w, sim[nrow(sim),1]/total_pop, sim[nrow(sim),2]/total_pop))
    }
  }
  
  # Store results
  results <- rbind(results, data.frame(f_w = f_w, 
                                       prob_rescue = rescue_count/num_rounds * 100, 
                                       prob_extinct = extinct_count/num_rounds * 100))
}

# Label the frequency data frame
colnames(freq_df) <- c("f_w", "wildtype", "mutant")

# --- Plot 1: Rescue probability vs wildtype fecundity ---
plot(results$f_w, results$prob_rescue, type = 'b',
     col = 'darkgreen', pch = 21,
     xlab = 'Wildtype adult fecundity (f_w)',
     ylab = 'Rescue probability (%)',
     main = 'Evolutionary Rescue vs Wildtype Fecundity')


```



## Rescue probability with varying mutant fecundity

```{r}
num_rounds <- 400
max_gen <- 200

# Range of mutant fecundity to explore
f_m_values <- seq(1, 6, by = 0.5)  # can adjust depending on biological realism

# Create result containers
results <- data.frame(f_m = numeric(), prob_rescue = numeric(), prob_extinct = numeric())
freq_df <- data.frame(array(NA, dim = c(0, 3), dimnames = list(c(), c("f_m", "wildtype", "mutant"))))

# Sweep over mutant fecundity values
for (f_m in f_m_values) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds) {
    
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, 
                        f_w = 3, f_m = f_m, 
                        hZ_w = 0.5, hZ_m = 0.5, 
                        pZ_w = 0.5, pZ_m = 0.5, 
                        mut_rate = 0.001, t_max = max_gen)
    
    total_pop <- sum(tail(sim, 1))
    
    if (total_pop == 0) { 
      extinct_count <- extinct_count + 1
    } else {
      rescue_count <- rescue_count + 1
      freq_df <- rbind(freq_df, c(f_m, sim[nrow(sim), 1]/total_pop, sim[nrow(sim), 2]/total_pop))
    }
  }
  
  # Store results
  results <- rbind(results, data.frame(f_m = f_m, 
                                       prob_rescue = rescue_count/num_rounds * 100, 
                                       prob_extinct = extinct_count/num_rounds * 100))
}

# Label the frequency data frame
colnames(freq_df) <- c("f_m", "wildtype", "mutant")

# Plot 1 — Rescue probability vs mutant fecundity
plot(results$f_m, results$prob_rescue, type = 'b',
     col = 'darkgreen', pch = 21,
     xlab = 'Mutant adult fecundity (f_m)',
     ylab = 'Rescue probability (%)',
     main = 'Evolutionary Rescue vs Mutant Fecundity')

```



## Rescue probability with varying wildtype hatching rate 

```{r}
# Setting number of rounds and maximum population number
num_rounds <- 400
max_gen <- 200

# Setting the varying wildtype hatching rates
hZ_w_values <- seq(0.1, 0.9 , by = 0.1)

# Making matrices to store the output
results <- data.frame(hZ_w = numeric(), prob_rescue = numeric(), prob_extinct = numeric())
freq_df <- data.frame(array(NA, dim =c(0,3), dimnames = list(c(), c("hZ_w", "wildtype", "mutant"))))

# Sweep over wildtype hatching rate
for (hZ_w in hZ_w_values) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds){
    
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                        hZ_w = hZ_w, hZ_m = 0.5, pZ_w = 0.5, pZ_m = 0.5, 
                        mut_rate = 0.001, t_max = max_gen)
    
    total_pop <- sum(tail(sim, 1))
    
    if (total_pop == 0){ 
      extinct_count <- extinct_count + 1
    } else {
      rescue_count <- rescue_count + 1
      freq_df <- rbind(freq_df, c(hZ_w, sim[nrow(sim),1]/total_pop, sim[nrow(sim),2]/total_pop))
    }
  }
  
  # store results
  results <- rbind(results, data.frame(hZ_w = hZ_w, 
                                       prob_rescue = rescue_count/num_rounds * 100, 
                                       prob_extinct = extinct_count/num_rounds * 100))
}

# Adding column names to frequency data frame because they don't get saved for
# some reason
colnames(freq_df) <- c("hZ_w", "wildtype", "mutant")

# plots
plot(results$hZ_w, results$prob_rescue, type='b',  
     col='darkgreen', pch=21, xlab='Wildtype hatching rate', 
     ylab='Rescue probability (%)',
     main='Evolutionary Rescue vs Wildtype hatching Rate')

```


## Rescue probability with varying mutant hatching rate

```{r}

# Setting number of rounds and maximum population number
num_rounds <- 400
max_gen <- 200

# Setting the varying mutant hatching rates
hZ_m_values <- seq(0, 1 , by = 0.1)


# Making matrices to store the output
results <- data.frame(hZ_m = numeric(), prob_rescue = numeric(), prob_extinct = numeric())

freq_df <- data.frame(array(NA, dim =c(0,3), dimnames = list(c(), c("hZ_m", "wildtype", "mutant"))))


# Loop to calculate rescue probability through each parameter combinations for x number of rounds
for (hZ_m in hZ_m_values) {
  
  extinct_count <- 0
  rescue_count <- 0
  
  for (i in 1:num_rounds){
    
    
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50, f_w = 3, f_m = 3, 
                        hZ_w = 0.3, hZ_m = hZ_m, pZ_w = 0.5, pZ_m = 0.5, 
                        mut_rate = 0.001, t_max = max_gen)
  
    total_pop <- sum(tail(sim, 1))
    
    
    if (total_pop == 0){ 
      extinct_count <- extinct_count + 1
      
    }
    else{
      rescue_count <- rescue_count + 1
      
      # Storing end frequency of wildtype and mutant at the end of simulation
      freq_df <- rbind(freq_df, c(hZ_m, sim[nrow(sim),1]/total_pop, 
                                  sim[nrow(sim),2]/total_pop))
    }
  }
  
  # Result for each mutation rate
  results <- rbind(results, data.frame(hZ_m = hZ_m, 
                     prob_rescue = rescue_count/num_rounds * 100,
                     prob_extinct = extinct_count/num_rounds * 100))
}
print(results)

# Adding column names to frequency data frame because they don't get saved for
# some reason
colnames(freq_df) <- c("hZ_m", "wildtype", "mutant")

# Plot for rescue probability
plot(results$hZ_m, results$prob_rescue, type='b',  
     col='darkgreen', pch=21, xlab='Mutant hatching rate', 
     ylab='Rescue probability (%)',
     main='Evolutionary Rescue vs Mutant hatching Rate hZ_w=0.4')

```


## Heatmaps 

### mutant hatching rate vs mutant fecundity

```{r}

# Loading package
library(ggplot2)

# Setting ranges for the parameters
hZ_m_values <- seq(0, 0.9, by = 0.1)
f_m_values <- seq(0, 10, by = 0.5)

num_rounds <- 400
max_gen <- 200

# Storing all possible combinations of mutant hatching rate and fecundity values in matrix
results_matrix <- expand.grid(hZ_m = hZ_m_values, f_m = f_m_values)

# Preparing empty column for rescue probability 
results_matrix$prob_rescue <- NA

# Loop to calculate rescue probability for each parameter combination for x number of rounds 
for (i in 1:nrow(results_matrix)) {
  hZ_m <- results_matrix$hZ_m[i]
  f_m <- results_matrix$f_m[i]
  
  rescue_count <- 0
  
  for (rep in 1:num_rounds) {
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50,
                        f_w = 2, f_m = f_m,
                        hZ_w = 0.5, hZ_m = hZ_m,
                        pZ_w = 0.4, pZ_m = 0.55,
                        mut_rate = 0.001, t_max = max_gen)
    total_pop <- sum(tail(sim, 1))
    if (total_pop > 0) rescue_count <- rescue_count + 1
  }
  
  results_matrix$prob_rescue[i] <- rescue_count / num_rounds * 100
}

# Plotting heatmap
ggplot(results_matrix, aes(x = f_m, y = hZ_m, fill = prob_rescue)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(name = "Rescue Probability (%)") +
  labs(x = "Mutant fecundity (f_m)", y = "Mutant hatching rate (hZ_m)",
       title = "Heatmap: Evolutionary Rescue Probability n_400") +
  theme_minimal()

```


### Mutant Fecundity vs Wildtype Fecundity

Testing how both mutant and wildtype fecundity together influence the rescue probability of the population.

```{r}

# Define parameter ranges
f_w_values <- seq(0, 5, by = 0.1)   
f_m_values <- seq(0, 5, by = 0.1)   

# Determining number of rounds and maximum number of generations
num_rounds <- 200   
max_gen <- 200       

# Storing all possible combinations of fecundity values in matrix
results_matrix <- expand.grid(f_w = f_w_values, f_m = f_m_values)

# Preparing empty column for rescue probability 
results_matrix$prob_rescue <- NA

# Loop to calculate rescue probability through each parameter combinations for x number of rounds
for (i in 1:nrow(results_matrix)) {
  f_w <- results_matrix$f_w[i]
  f_m <- results_matrix$f_m[i]
  
  rescue_count <- 0
  
  for (rep in 1:num_rounds) {
    sim <- simulate_pop(Z_init_w = 100, Z_init_m = 50,
                        f_w = f_w, f_m = f_m,
                        hZ_w = 0.5, hZ_m = 0.55,
                        pZ_w = 0.4, pZ_m = 0.55,
                        mut_rate = 0.001, t_max = max_gen)
    
    total_pop <- sum(tail(sim, 1))
    if (total_pop > 0) rescue_count <- rescue_count + 1
  }
  
  # Calculate rescue probability
  results_matrix$prob_rescue[i] <- rescue_count / num_rounds * 100
}

# plot: Heatmap of Rescue Probability
ggplot(results_matrix, aes(x = f_w, y = f_m, fill = prob_rescue)) +
  geom_tile(color = "white") +
  scale_fill_viridis_c(name = "Rescue Probability (%)") +
  labs(
    x = "Wildtype fecundity (f_w)",
    y = "Mutant fecundity (f_m)",
    title = "Heatmap: Evolutionary Rescue vs Fecundity of Wildtype and Mutant n_200"
  ) +
  theme_minimal(base_size = 13)

```
